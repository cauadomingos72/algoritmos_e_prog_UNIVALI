#include <iostream>
#include <string>
#include <cmath>
#include <queue>

using namespace std;

// Struct, Nós e Links
typedef struct No_T3
{
    char VxO; // Valor ou Operador
    No_T3 *Esq; // * Esquerda
    No_T3 *Dir; // * Direita
    No_T3 *Pai; // Pai do No
    int P; // Prioridade
} *Link, No;

//Salva posi��o para ordena��o da arvore;
Link Bonsai, Raiz, aux;

// Variaveis para suporte;
int Mult=1, DebuCount=0;

bool vNumero(char C)
{
    if((C >= '0')&&(C <= '9'))
        return true;
    else
        return false;
}// Verifica se � numero

bool vOperador(char C)
{
    if((C == '+') || (C == '-') || (C == '*') || (C == '/'))
        return true;
    else
        return false;
}// Verifica se � Operador

int Prioridade(char C)
{
    if(C == ' ')
        return 0;
    else
    {
        if(C=='+' || C=='-')
            return 2*Mult;
        if(C=='/' || C=='*')
            return 4*Mult;
        else
            return 6*Mult;
    }
}//Verifica Prioridade de Cada Char

Link encontra(Link X,int P)
{
    if ((X->P > P) && (vOperador(X->VxO)))
    {
        return X;
    }
    else
    {
        if(X->Esq!=NULL)
            encontra(X->Esq,P);
        if(X->Dir!=NULL)
            encontra(X->Dir,P);

        if((X->Esq==NULL) && (X->Dir==NULL))
            return X;
    }
}

Link Novo_No(char C, int P)
{
    Link Novo = new No;

    DebuCount++;

    if (Bonsai == NULL)
    {
        Raiz = Novo;
        Bonsai = Novo;
    }

    Novo->VxO = C;
    Novo->Esq = NULL;
    Novo->Dir = NULL;
    Novo->Pai = NULL;
    Novo->P = P;
    return Novo;
}//Cria novo No com char e prioridade;

void Insere_T3(Link Temp)
{
    if(Temp == Raiz)
        return;

    //Se � um numero Temp
    if (vNumero(Temp->VxO))
    {
        Bonsai->Dir = Temp;
        return;
    }

    //Se Pai � um numero Bonsai
    if (vNumero(Bonsai->VxO))
    {
        Temp->Esq = Bonsai;
        Bonsai->Pai = Temp;
        Raiz = Temp;
        Bonsai = Temp;
    }

    // Se � um operador
    if (vOperador(Bonsai->VxO))
    {

        // Se prioridade do operador for menor
        // insere antes da raiz
        if (Temp->P < Bonsai->P)
        {
            Temp->Esq = Bonsai;
            Bonsai->Pai = Temp;
            Bonsai = Temp;
        }
        // Se prioridade do operador for menor ou igual
        // insere entre raiz e resto
        if (Temp->P <= Bonsai->P)
        {
            Temp->Esq = Bonsai->Dir;
            Bonsai->Dir = Temp;
            Temp->Pai = Bonsai;
            Bonsai = Temp;
        }

        // Se prioridade do operador for maior
        // procura local correto
        if (Temp->P > Bonsai->P)
        {
            Link Nav;
            // Insere no nivel correto
            Nav = encontra(Raiz,Temp->P);

            if(Nav->Dir == NULL)
            {
                Nav->Dir=Temp;
            }
            if(Nav->Esq == NULL)
            {
                Nav->Esq=Temp;
            }
        }
    }
}//Insere na arovre na posi��o correta

void Insere_T3_2 (Link Temp)
{
    // Se Raiz == Temp ent�o temp ja foi o primeiro inserido
    if (Temp == Raiz){
            //cout<<"_A   ";
        return;
    }

    //Se Temp->VxO � um numero
    if (vNumero(Temp->VxO))
    {
        Bonsai->Dir = Temp;
        //cout<<"_B   ";
        return;
    }

    //Se Bonsai->VxO � um numero
    if (vNumero(Bonsai->VxO))
    {
        Temp->Esq = Bonsai;
        Bonsai->Pai = Temp;
        Raiz = Temp;
        Bonsai = Temp;
        //cout<<"_C   ";
    }
    else// Se � um operador
    {
        if (Temp->P > Bonsai->P)//Se Temp->P maior que Bonsai->P insere.
        {
            Temp->Esq = Bonsai->Dir;
            Bonsai->Dir = Temp;
            Temp->Pai = Bonsai;
            Bonsai = Temp;
            //cout<<"_D   ";
        }
        else
        {
            // Acha o Nivel correto de acordo com a prioridade
            while(1)
            {
                if (Bonsai->Pai == NULL)//Se pai do Bonsai � nulo quebra while
                {
                    //cout<<"_E   ";
                    Bonsai->Pai = Temp;
                    Temp->Esq = Bonsai;
                    Bonsai = Temp;
                    Raiz = Temp;
                    break;
                }
                else
                {
                    if (Temp->P < Bonsai->P)//Se Temp->P menor que Bonsai->P
                    {
                        if (Temp->P > Bonsai->Pai->P){//Se Temp->P maior que Bonsai->Pai->P
                            //cout<<"_F   ";
                            break;//Quebra while
                        }
                        else
                        {
                            cout<<"_G   ";
                            Bonsai = Bonsai->Pai;//Volta Bonsai para Pai
                        }
                    }
                    else////Se Temp->P maior que Bonsai->P
                    {
                        //cout<<"_H   ";
                        break;//Quebra while
                    }
                    //cout<<"_I   ";
                    Temp->Esq = Bonsai;//Temp->Esq se torna Bonsai
                    if (Bonsai == Raiz)//Se Bonsai igual Raiz, Raiz se torna Temp;
                    {
                        //cout<<"_J   ";
                        Raiz = Temp;
                    }
                    else//Caso Bonsai n�o seja Raiz
                    {
                        if (Bonsai->Pai->Esq == Bonsai)//Se Bonsai->Pai>Esq igual Bonsai
                        {
                            //cout<<"_K   ";
                            Bonsai->Pai->Esq = Temp;//Temp se torna Bonsai->Pai->Esq
                        }
                        else//Se Bonsai->Pai>Esq diferente de Bonsai
                        {
                            //cout<<"_L   ";
                            Bonsai->Pai->Dir = Temp;//Temp se torna Bonsai->Pai->Dir
                        }
                        //cout<<"_M   ";
                        Temp->Pai = Bonsai->Pai;
                        Bonsai->Pai = Temp;//Temp se torna pai de Bonsai
                    }
                }
                //cout<<"_N   ";
                Bonsai = Temp;
            }
        }
    }
} // TExp_Insere

void Monta_T3(Link&Arvore, string Exp)
{
    Arvore = NULL;
    Link Temp;

    for(int i=0; i<Exp.size(); i++)  //Separa Prioridades
    {
        if(Exp[i] == '(' or Exp[i] == ')')
        {
            if(Exp[i] == '(')
            {
                Mult *= 10;
            }
            if(Exp[i] == ')')
            {
                Mult /= 10;
            }
        }
        else if(Exp[i] != ' ')
        {
            Temp = Novo_No(Exp[i],Prioridade(Exp[i]));
            //cout<<Temp->VxO;
            Insere_T3_2(Temp);
        }
    }
    Arvore = Raiz;
}//Constroi Arovore

int Calcula(Link L)
{
    int A, B;

    if(L!=NULL)
    {
        if (vNumero(L->VxO))
            return L->VxO-'0';

        if((L->Esq == NULL) && (L->Dir == NULL))
            return 0;
        else
        {
            A=Calcula(L->Esq);
            B=Calcula(L->Dir);

            switch (L->VxO)
            {
            case '+':
                return (A+B);
            case '-':
                return (A-B);
            case '*':
                return (A*B);
            case '/':
                return (A/B);
            }
        }
    }
    return 0;
}//Calcula;





void printSpace(double n, No_T3* removed)
{
	for (; n > 0; n--) {
		cout << "\t";
	}
	if (removed == nullptr) {
		cout << " ";
	}
	else {
		cout << removed->VxO;
	}
}

int heightOfTree(No_T3* root)
{
	if (root == nullptr) {
		return 0;
	}
	return 1
		+ max(heightOfTree(root->Esq),
				heightOfTree(root->Dir));
}

void printBinaryTree(No_T3* root)
{
	queue<No_T3*> treeLevel, temp;
	treeLevel.push(root);
	int counter = 0;
	int height = heightOfTree(root) - 1;
	double numberOfElements = pow(2, (height + 1)) - 1;
	while (counter <= height) {
		No_T3* removed = treeLevel.front();
		treeLevel.pop();
		if (temp.empty()) {
			printSpace(numberOfElements / pow(2, counter + 1),removed);
		}
		else {
			printSpace(numberOfElements / pow(2, counter),removed);
		}
		if (removed == nullptr) {
			temp.push(nullptr);
			temp.push(nullptr);
		}
		else {
			temp.push(removed->Esq);
			temp.push(removed->Dir);
		}
		if (treeLevel.empty()) {
			cout << endl << endl;
			treeLevel = temp;
			while (!temp.empty()) {
				temp.pop();
			}
			counter++;
		}
	}
}



int main()
{
	No_T3* root = new No_T3();

    string Exp;
    cout << "Digite a Expresao que sera calculada: \nObs: somente aceito de 0 a 9, () ou + - / *, e sem espacos \n" << "> \n";
    cin>>Exp;
    //cout<<"Expressão: "<<"( 6 + 6 ) + 8 / ( 9 - 7 )"<<endl<<endl;
    cout<<endl<<endl;
    //cout<<"Debug=";
    string vet1= "-**4352";
    string vet2={"-**++++81726354"};
    Monta_T3(root,Exp);

	printBinaryTree(root);
	cout<<endl<<endl<<"Resultado: "<<Calcula(root);

	return 0;
}
